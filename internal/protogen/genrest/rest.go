package genrest

import (
	"fmt"
	"net/http"
	"regexp"
	"strings"

	"github.com/imkuqin-zw/yggdrasil/pkg/utils/xstrings"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	httpPkg        = protogen.GoImportPath("net/http")
	ctxPkg         = protogen.GoImportPath("context")
	ioPkg          = protogen.GoImportPath("io")
	marshalerPkg   = protogen.GoImportPath("github.com/imkuqin-zw/yggdrasil/pkg/rest/marshaler")
	statusPkg      = protogen.GoImportPath("github.com/imkuqin-zw/yggdrasil/pkg/status")
	interceptorPkg = protogen.GoImportPath("github.com/imkuqin-zw/yggdrasil/pkg/interceptor")
	restPkg        = protogen.GoImportPath("github.com/imkuqin-zw/yggdrasil/pkg/rest")
	svrPkg         = protogen.GoImportPath("github.com/imkuqin-zw/yggdrasil/pkg/server")
	codePkg        = protogen.GoImportPath("google.golang.org/genproto/googleapis/rpc/code")
)

var methodSets = make(map[string]int)

// GenerateFiles generates a _rest.pb.go file containing yggdrasil errors definitions.
func GenerateFiles(gen *protogen.Plugin, file *protogen.File) error {
	pass := false
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
			if rule != nil && ok {
				pass = true
				break
			}
		}
		if pass {
			break
		}
	}
	if !pass {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_rest.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-yggdrasil-rest. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	return generateFileContent(gen, file, g)
}

// generateFileContent generates the yggdrasil errors definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) error {
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the yggdrasil package it is being compiled against.")
	g.P("var _ = new(", marshalerPkg.Ident("ProtoMarshaller"), ")")
	g.P("var _ = ", ioPkg.Ident("EOF"))

	g.P()
	for _, service := range file.Services {
		if err := genService(gen, file, g, service); err != nil {
			return err
		}
	}
	return nil
}

func genService(_ *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) error {
	if len(service.Methods) == 0 {
		return nil
	}
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	// HTTP Server.
	sd := &serviceDesc{
		//ChiPkg:         g.QualifiedGoIdent(chiPkg.Ident("")),
		HttpPkg:        g.QualifiedGoIdent(httpPkg.Ident("")),
		MarshalerPkg:   g.QualifiedGoIdent(marshalerPkg.Ident("")),
		StatusPkg:      g.QualifiedGoIdent(statusPkg.Ident("")),
		RestPkg:        g.QualifiedGoIdent(restPkg.Ident("")),
		SvrPkg:         g.QualifiedGoIdent(svrPkg.Ident("")),
		CodePkg:        g.QualifiedGoIdent(codePkg.Ident("")),
		CtxPkg:         g.QualifiedGoIdent(ctxPkg.Ident("")),
		IoPkg:          g.QualifiedGoIdent(ioPkg.Ident("")),
		InterceptorPkg: g.QualifiedGoIdent(interceptorPkg.Ident("")),

		ServiceType: service.GoName,
		ServiceName: string(service.Desc.FullName()),
	}

	for _, method := range service.Methods {
		if err := buildMethod(sd, g, method); err != nil {
			return err
		}
	}
	for _, item := range sd.Methods {
		if len(item.PathVars) > 0 {
			sd.ChiPkg = g.QualifiedGoIdent(protogen.GoImportPath("github.com/go-chi/chi/v5").Ident(""))
		}
	}
	g.P(sd.execute())
	return nil
}

func buildMethod(sd *serviceDesc, g *protogen.GeneratedFile, method *protogen.Method) error {
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		return nil
	}
	rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
	if !ok || rule == nil {
		return nil
	}
	for _, bind := range rule.AdditionalBindings {
		item, err := buildHTTPRule(g, method, bind)
		if err != nil {
			return err
		}
		if item == nil {
			continue
		}
		sd.Methods = append(sd.Methods, item)
	}
	item, err := buildHTTPRule(g, method, rule)
	if err != nil {
		return err
	}
	if item == nil {
		return nil
	}
	sd.Methods = append(sd.Methods, item)
	return nil
}

func buildHTTPRule(g *protogen.GeneratedFile, m *protogen.Method, rule *annotations.HttpRule) (*methodDesc, error) {
	var (
		path   string
		method string
		body   string
	)
	switch pattern := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		path = pattern.Get
		method = "GET"
	case *annotations.HttpRule_Put:
		path = pattern.Put
		method = "PUT"
	case *annotations.HttpRule_Post:
		path = pattern.Post
		method = "POST"
	case *annotations.HttpRule_Delete:
		path = pattern.Delete
		method = "DELETE"
	case *annotations.HttpRule_Patch:
		path = pattern.Patch
		method = "PATCH"
	case *annotations.HttpRule_Custom:
		path = pattern.Custom.Path
		method = pattern.Custom.Kind
	}

	md, err := buildMethodDesc(g, m, method, path)
	if err != nil {
		return nil, err
	}

	body = rule.Body
	if method == http.MethodGet || method == http.MethodDelete {
		if body != "" {
			return nil, fmt.Errorf("%s %s body should not be declared", method, path)
		}
	} else {
		if body == "" {
			return nil, fmt.Errorf("%s %s does not declare a body", method, path)
		}
	}

	if body == "*" {
		body = ""
		md.HasBody = true
	} else if body != "" {
		md.HasBody = true
		md.Body = "." + camelCaseVars(body)
	}

	return md, nil
}

func buildMethodDesc(g *protogen.GeneratedFile, m *protogen.Method, method, path string) (*methodDesc, error) {
	defer func() { methodSets[m.GoName]++ }()
	desc := &methodDesc{
		Name:    m.GoName,
		Num:     methodSets[m.GoName],
		Request: g.QualifiedGoIdent(m.Input.GoIdent),
		Method:  method,
	}
	desc.Path, desc.PathVars = buildPathVars(path)
	return desc, nil
}

var (
	pathPattern = regexp.MustCompile(`(?i){([a-z.0-9_\s]+)=?([^{}]*)}`)
	subPattern  = regexp.MustCompile(`(?i)(/[*]+)`)
)

func buildPathVars(path string) (string, map[string]string) {
	nameVars := make(map[string]string)
	paramsIdx := 0

	path = pathPattern.ReplaceAllStringFunc(path, func(s string) string {
		params := pathPattern.FindStringSubmatch(s)
		name := strings.TrimSpace(params[1])
		if len(params) <= 2 {
			s = fmt.Sprintf("{params%d}", paramsIdx)
			nameVars[name] = s
			paramsIdx++
			return s
		}

		if strings.HasPrefix(params[1], "/") || strings.HasSuffix(params[1], "/") {
			s = fmt.Sprintf("{params%d}", paramsIdx)
			nameVars[name] = s
			paramsIdx++
			return s
		}
		values := strings.Split(params[2], "/")
		if len(values)%2 == 1 {
			s = fmt.Sprintf("{params%d}", paramsIdx)
			nameVars[name] = s
			paramsIdx++
			return s
		}

		s = subPattern.ReplaceAllStringFunc(params[2], func(s string) string {
			s = fmt.Sprintf("/{params%d}", paramsIdx)
			paramsIdx++
			return s
		})
		nameVars[name] = s
		return s
	})

	return path, nameVars
}

func camelCaseVars(s string) string {
	var (
		vars []string
		subs = strings.Split(s, ".")
	)
	for _, sub := range subs {
		vars = append(vars, xstrings.StrToCamelCase(sub))
	}
	return strings.Join(vars, ".")
}

const deprecationComment = "// Deprecated: Do not use."
