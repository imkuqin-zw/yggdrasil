// Copyright 2022 The imkuqin-zw Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package genrpc

import (
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	typesPackage   = protogen.GoImportPath("github.com/imkuqin-zw/yggdrasil/pkg/types")
	errorsPackage  = protogen.GoImportPath("github.com/imkuqin-zw/yggdrasil/pkg/errors")
	codePackage    = protogen.GoImportPath("google.golang.org/genproto/googleapis/rpc/code")
)

var methodSets = make(map[string]int)

func GenerateFiles(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}
	generateClientFile(gen, file)
	generateServerFile(gen, file)
}

func generateClientFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_client.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	generateHeader(g, file)
	generateFileContent(gen, file, g, false)
}

func generateServerFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_server.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	generateHeader(g, file)
	generateFileContent(gen, file, g, true)
}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-yggdrasil-rpc. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

// generateFileContent generates the kratos errors definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, isServer bool) {
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the yggdrasil package it is being compiled against.")
	// g.P("var _ = new(", contextPackage.Ident("Context"), ")")
	g.P()

	for _, service := range file.Services {
		if len(service.Methods) > 0 {
			genService(g, service, isServer)
		}

	}
}

func genService(g *protogen.GeneratedFile, service *protogen.Service, isServer bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}

	sd := &serviceDesc{
		ServiceType: service.GoName,
		ServiceName: string(service.Desc.FullName()),
		Context:     g.QualifiedGoIdent(contextPackage.Ident("Context")),
	}
	needType := false
	for _, method := range service.Methods {
		tmp := &methodDesc{
			Name:         method.GoName,
			Input:        g.QualifiedGoIdent(method.Input.GoIdent),
			Output:       g.QualifiedGoIdent(method.Output.GoIdent),
			ClientStream: method.Desc.IsStreamingClient(),
			ServerStream: method.Desc.IsStreamingServer(),
		}
		if tmp.ClientStream || tmp.ServerStream {
			needType = true
		}
		sd.Methods = append(sd.Methods, tmp)
	}
	if needType {
		sd.Types = g.QualifiedGoIdent(typesPackage.Ident(""))
	}
	if isServer {
		sd.Errors = g.QualifiedGoIdent(errorsPackage.Ident(""))
		sd.Code = g.QualifiedGoIdent(codePackage.Ident(""))
	}
	if len(sd.Methods) != 0 {
		if isServer {
			g.P(sd.execute(serverTpl))
		} else {
			g.P(sd.execute(clientTpl))
		}
	}
}

const deprecationComment = "// Deprecated: Do not use."
