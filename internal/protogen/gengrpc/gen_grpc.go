package gengrpc

import (
	"fmt"
	"path"
	"strings"

	"github.com/imkuqin-zw/yggdrasil/pkg/utils/xstrings"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
	mdPackage      = protogen.GoImportPath("github.com/imkuqin-zw/yggdrasil/pkg/md")
	grpcMdPackage  = protogen.GoImportPath("google.golang.org/grpc/metadata")
)

var methodSets = make(map[string]int)

func GenerateFiles(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}
	generateFile(gen, file)
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := path.Join(
		path.Dir(file.GeneratedFilenamePrefix),
		"grpc",
		path.Base(file.GeneratedFilenamePrefix)+"_grpc.pb.go",
	)
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	generateHeader(g, file)
	generateFileContent(gen, file, g)

}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-yggdrasil-grpc. DO NOT EDIT.")
	g.P()
	g.P("package ", "grpcimpl")
	g.P()
}

// generateFileContent generates the kratos errors definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the yggdrasil package it is being compiled against.")
	g.P()

	for _, service := range file.Services {
		genService(g, service, file)
	}
}

func genService(g *protogen.GeneratedFile, service *protogen.Service, file *protogen.File) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	interfaceImport := strings.Split(*file.Proto.Options.GoPackage, ";")[0]
	sd := &serviceDesc{
		Filename:              file.GeneratedFilenamePrefix + ".proto",
		ServiceType:           service.GoName,
		LowerFirstServiceType: xstrings.StrToLowerFirstCamelCase(service.GoName),
		ServiceName:           string(service.Desc.FullName()),
		FullServerName:        service.GoName,
		InterfaceImport:       g.QualifiedGoIdent(protogen.GoImportPath(interfaceImport).Ident("")),
		Context:               g.QualifiedGoIdent(contextPackage.Ident("Context")),
		Grpc:                  g.QualifiedGoIdent(grpcPackage.Ident("")),
	}
	pkg := file.Desc.FullName()
	if len(pkg) > 0 {
		sd.FullServerName = string(pkg) + "." + sd.FullServerName
	}
	hasStream := false
	for _, method := range service.Methods {
		input := protogen.GoImportPath(interfaceImport).Ident(method.Input.GoIdent.GoName)
		output := protogen.GoImportPath(interfaceImport).Ident(method.Output.GoIdent.GoName)
		tmp := &methodDesc{
			Name:         method.GoName,
			FullName:     fmt.Sprintf("/%s/%s", sd.FullServerName, method.GoName),
			Input:        g.QualifiedGoIdent(input),
			Output:       g.QualifiedGoIdent(output),
			ClientStream: method.Desc.IsStreamingClient(),
			ServerStream: method.Desc.IsStreamingServer(),
		}
		if tmp.ClientStream || tmp.ServerStream {
			hasStream = true
		}
		sd.Methods = append(sd.Methods, tmp)
	}
	if hasStream {
		sd.Md = g.QualifiedGoIdent(mdPackage.Ident(""))
		sd.GrpcMd = g.QualifiedGoIdent(grpcMdPackage.Ident(""))
	}
	if len(sd.Methods) != 0 {
		g.P(sd.execute(tpl))
	}
}

const deprecationComment = "// Deprecated: Do not use."
